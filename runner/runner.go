package runner

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"

	"github.com/hashicorp/go-multierror"

	"github.com/ejohn/go-atomic/art"
)

// Runner is an atomic red team test runner.
type Runner struct {
	AtomicsFolder string
	Logger        Logger

	techniques map[string]*art.Technique
	guids      map[string]*art.Test
}

// Logger interface that the users of Runner need to satisfy to enable debug logging.
type Logger interface {
	Printf(string, ...interface{})
}

func (ar *Runner) debugf(format string, args ...interface{}) {
	if ar.Logger != nil {
		ar.Logger.Printf(format, args)
	}
}

// LoadTechniques loads the atomic tests into the runner.
func (ar *Runner) LoadTechniques() error {
	if ar.AtomicsFolder == "" {
		return fmt.Errorf("set atomics folder before loading techniques")
	}
	ar.debugf("loading techniques from directory %s", ar.AtomicsFolder)
	techniques := ar.processYAMLFolder()
	if len(techniques) == 0 {
		return fmt.Errorf("unable to load techniques from directory %s", ar.AtomicsFolder)
	}
	ar.techniques = make(map[string]*art.Technique)
	ar.guids = make(map[string]*art.Test)

	for techID := range techniques {
		tech := techniques[techID]
		ar.techniques[tech.ID] = &tech

		for testID := range tech.AtomicTests {
			test := tech.AtomicTests[testID]
			if test.AutoGeneratedGUID != "" {
				ar.guids[test.AutoGeneratedGUID] = test
			}
		}
	}
	return nil
}

// GetAllTechniques gets a list of all valid techniques found inside the atomics folder.
func (ar *Runner) GetAllTechniques() []*art.Technique {
	var techniques []*art.Technique
	for _, technique := range ar.techniques {
		techniques = append(techniques, technique)
	}
	return techniques
}

// GetTechnique get a technique by its ID.
func (ar *Runner) GetTechnique(techniqueID string) (*art.Technique, error) {
	techniqueID = strings.TrimSpace(techniqueID)
	technique, found := ar.techniques[techniqueID]
	if !found {
		return nil, fmt.Errorf("invalid technique id %s", techniqueID)
	}

	return technique, nil
}

// GetTestByIDAndIndex get an atomic test from a technique by its zero based index.
func (ar *Runner) GetTestByIDAndIndex(techniqueID string, index int) (*art.Test, error) {
	techniqueID = strings.TrimSpace(techniqueID)
	technique, found := ar.techniques[techniqueID]
	if !found {
		return nil, fmt.Errorf("%s is not a valid technique", techniqueID)
	}
	if index < 0 || index >= len(technique.AtomicTests) {
		return nil, fmt.Errorf("index is not valid for %s [%d tests total]",
			techniqueID, len(technique.AtomicTests))
	}
	atomicTest := technique.AtomicTests[index]
	return atomicTest, nil
}

// GetTestByGUID gets an atomic test by its autogenerated guid.
func (ar *Runner) GetTestByGUID(guid string) (*art.Test, error) {
	test, ok := ar.guids[guid]
	if !ok {
		return nil, fmt.Errorf("no test with guid %s found", guid)
	}
	return test, nil
}

// GetTestByIDAndName gets an atomic test from a technique by its name.
func (ar *Runner) GetTestByIDAndName(techniqueID string, wantName string) (*art.Test, error) {
	techniqueID = strings.TrimSpace(techniqueID)
	technique, found := ar.techniques[techniqueID]
	if !found {
		return nil, fmt.Errorf("%q is not a valid technique", techniqueID)
	}

	type foundTest struct {
		index int
		at    *art.Test
	}
	var tests []foundTest
	for index, test := range technique.AtomicTests {
		// continue iterating since there are techniques which have multiple tests
		// with the same name. unfortunate. revisit in future.
		if wantName == test.Name {
			tests = append(tests, foundTest{index, test})
		}
	}
	if len(tests) == 0 {
		return nil, fmt.Errorf("no test found with name %q", wantName)
	}
	if len(tests) > 1 {
		var indexes []string
		for _, test := range tests {
			indexes = append(indexes, strconv.Itoa(test.index))
		}
		return nil, fmt.Errorf("multiple tests found with the same name %q "+
			"found at indexes %s", wantName, strings.Join(indexes, ","))
	}
	return tests[0].at, nil
}

// BuildTest builds an atomic test and gets it ready for execution by substituting the
// supplied input arguments in the commands. This method is helpful to dry run a test
// and verify what will get executed. If nil is passed in as the arguments parameter, default
// arguments provided with the test case are used.
func (ar *Runner) BuildTest(atomicTest *art.Test, arguments map[string]string) (*BuiltTest, error) {
	if atomicTest == nil {
		return nil, fmt.Errorf("atomic test cannot be nil")
	}
	bt := &BuiltTest{
		TechniqueID: atomicTest.TechniqueID,
		TestName:    atomicTest.Name,
		TestGUID:    atomicTest.AutoGeneratedGUID,
		Executor:    atomicTest.Executor.Name,
		Platform:    getCurrentPlatform(),
	}

	// build arguments for atomic test and clean up command
	args := buildArguments(atomicTest.InputArguments, arguments, ar.AtomicsFolder)
	commands, err := buildCommands(atomicTest.Executor.Command, args, ar.AtomicsFolder)
	if err != nil {
		return bt, fmt.Errorf("failed to build command for test %q, %s", atomicTest.Name, err)
	}
	cleanupCommands, err := buildCommands(atomicTest.Executor.CleanupCommand, args, ar.AtomicsFolder)
	if err != nil {
		return bt, fmt.Errorf("failed to build cleanup commands for test %q, %s", atomicTest.Name, err)
	}

	// test support is checked at this point so that the partially built test is still
	// useful for debugging even though it cannot be run on the current platform.
	err = verifyTestIsSupported(atomicTest)
	if err != nil {
		return bt, err
	}
	launcher, err := getLauncher(atomicTest.Executor.Name)
	if err != nil {
		if err == errUnsupportedExecutor {
			// TODO: we are not doing anything with this information for the time being. change or remove?
		} else {
			return bt, fmt.Errorf("error getting launcher: %s", err)
		}
	}

	// build dependencies if any
	depInfo, err := buildDependency(atomicTest, args, ar.AtomicsFolder)
	if err != nil {
		return bt, fmt.Errorf("failed to build dependency: %s", err)
	}

	// build the final test by combining all the parts
	bt.Launcher = launcher
	bt.Arguments = args
	bt.DependencyInfo = depInfo
	bt.AtomicTestCommands = commands
	bt.CleanupCommands = cleanupCommands

	return bt, nil
}

func buildDependency(atomicTest *art.Test, args map[string]string, atomicsFolder string) (*DependencyInfo, error) {
	// fallback to the atomic test executor if the optional dependency executor is not specified.
	depExecutor := atomicTest.DependencyExecutorName
	if depExecutor == "" {
		depExecutor = atomicTest.Executor.Name
	}

	// build dependencies if there are any
	var depInfo *DependencyInfo
	if len(atomicTest.Dependencies) > 0 {
		depInfo = &DependencyInfo{
			Executor:          depExecutor,
			supportedExecutor: true,
		}
		var err error
		depInfo.Launcher, err = getLauncher(depExecutor)
		if err != nil {
			if err == errUnsupportedExecutor {
				depInfo.supportedExecutor = false
			} else {
				return depInfo, fmt.Errorf("error getting dependency launcher: %s", err)
			}
		}
		for _, dependency := range atomicTest.Dependencies {
			getPreReqCommand, err := buildCommands(dependency.GetPrereqCommand, args, atomicsFolder)
			if err != nil {
				return depInfo, fmt.Errorf("failed to build getprereq command %q for test %q , %s",
					dependency.Description, atomicTest.Name, err)
			}
			preReqCommand, err := buildCommands(dependency.PrereqCommand, args, atomicsFolder)
			if err != nil {
				return depInfo, fmt.Errorf("failed to build prereq command %q for test %q , %s",
					dependency.Description, atomicTest.Name, err)
			}
			depInfo.Dependencies = append(depInfo.Dependencies,
				BuiltDependency{PreReqCmds: preReqCommand, GetPreReqCmds: getPreReqCommand})
		}
	}
	return depInfo, nil
}

func handleDependency(bt *BuiltTest, rc *TestRunConfig) (*DependencyRunInfo, error) {
	depLauncher := bt.DependencyInfo.Launcher
	dri := &DependencyRunInfo{
		Launcher: strings.Join(depLauncher, " "),
	}
	for _, dependency := range bt.DependencyInfo.Dependencies {
		var depResult DependencyRunResults
		// run prereq commands
		var err error

		depResult.PreReq, err = runCommands(depLauncher, dependency.PreReqCmds, rc.Timeout, rc.SplitCmdsByNewline)

		lastExitCode := depResult.PreReq[len(depResult.PreReq)-1].Result.ExitCode

		// Prereq check commands will return err if the they fail. A positive error indicates that
		// the check failed as intended due to the lack of satisfying prereqs.
		if err != nil && lastExitCode < 0 {
			dri.Dependencies = append(dri.Dependencies, depResult)
			return dri, RunTestError{PreReqError, err}
		}
		// Run getprereq command if prereq failed. A positive exit code is from the OS.
		// Exit code can also be negative when building or running the command fails
		var gprErr error
		if lastExitCode > 0 && (rc.EnableDependency || rc.EnableAll) {
			depResult.GetPreReq, gprErr = runCommands(depLauncher, dependency.GetPreReqCmds, rc.Timeout, rc.SplitCmdsByNewline)
		}
		dri.Dependencies = append(dri.Dependencies, depResult)
		if gprErr != nil {
			return dri, RunTestError{GetPreReqError, err}
		}
	}
	return dri, nil
}

// RunTestErrorType is used to annotate errors generated when an atomic test is run.
type RunTestErrorType string

// Various RunTestErrorType's generated when an atomic test is run.
const (
	PreReqError     RunTestErrorType = "prereq"
	GetPreReqError                   = "getprereq"
	AtomicTestError                  = "atomic test"
	CleanupError                     = "cleanup"
)

// RunTestError represents an error generated while running an atomic test.
type RunTestError struct {
	Type RunTestErrorType
	Err  error
}

func (rte RunTestError) Error() string {
	return fmt.Sprintf("%s failed: %s", rte.Type, rte.Err.Error())
}

// RunTest runs an atomic test.
func (ar *Runner) RunTest(atomicTest *art.Test, arguments map[string]string, rc *TestRunConfig) (*TestRunInfo, error) {
	if rc == nil {
		return nil, fmt.Errorf("test run config cannot be nil")
	}
	if atomicTest == nil {
		return nil, fmt.Errorf("atomic test cannot be nil")
	}

	tri := &TestRunInfo{
		TechniqueID: atomicTest.TechniqueID,
		TestName:    atomicTest.Name,
		TestGUID:    atomicTest.AutoGeneratedGUID,
		Platform:    getCurrentPlatform(),
		Executor:    atomicTest.Executor.Name,
	}
	err := verifyTestIsSupported(atomicTest)
	if err != nil {
		return tri, err
	}

	bt, err := ar.BuildTest(atomicTest, arguments)
	if err != nil {
		return tri, err
	}
	tri.Arguments = bt.Arguments
	tri.Launcher = bt.Launcher

	if rc.EnableAll || rc.EnableDependency || rc.EnableCheckPreReq {
		// handle dependencies if any
		if bt.DependencyInfo != nil {
			tri.DependencyInfo, err = handleDependency(bt, rc)
			if err != nil {
				return tri, err
			}
		}
	}

	var combinedErr error
	if rc.EnableTest || rc.EnableAll {
		var testErr error
		// run the actual test commands
		tri.AtomicTest, testErr = runCommands(bt.Launcher, bt.AtomicTestCommands, rc.Timeout, rc.SplitCmdsByNewline)
		if testErr != nil {
			combinedErr = multierror.Append(combinedErr, RunTestError{AtomicTestError, testErr})
		}
	}
	// run clean up even if the test fails
	if rc.EnableCleanup || (rc.EnableAll && bt.CleanupCommands != "") {
		var cleanupErr error
		tri.Cleanup, cleanupErr = runCommands(bt.Launcher, bt.CleanupCommands, rc.Timeout, rc.SplitCmdsByNewline)
		if cleanupErr != nil {
			combinedErr = multierror.Append(combinedErr, RunTestError{CleanupError, cleanupErr})
		}
	}
	return tri, combinedErr
}

const (
	windows = "windows"
	macos   = "macos" // atomic red team uses the term macos instead of darwin to mark tests that run on mac
	linux   = "linux"
	darwin  = "darwin"
)

func getCurrentPlatform() string {
	platform := runtime.GOOS
	if platform == darwin {
		platform = macos
	}
	return platform
}

func getCMDPromptForPlatform() ([]string, error) {
	platform := getCurrentPlatform()
	switch platform {
	case linux:
		return []string{"/bin/sh"}, nil
	case macos:
		return []string{"/bin/sh"}, nil
	case windows:
		return []string{"C:\\Windows\\System32\\cmd.exe"}, nil
	default:
		return []string{"/bin/sh"}, errUnsupportedExecutor
	}
}

var errUnsupportedExecutor = errors.New("unsupported executor")

func getLauncher(executorName string) ([]string, error) {
	switch executorName {
	case "command_prompt":
		return getCMDPromptForPlatform()
	case "powershell":
		return []string{"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe", "-Command", "-"}, nil
	case "sh":
		return []string{"/bin/sh"}, nil
	case "bash":
		return []string{"/bin/bash"}, nil
	case "manual":
		return []string{}, fmt.Errorf("test with manual executor cannot be run")
	case "":
		return []string{}, fmt.Errorf("executor name not provided")
	default:
		return []string{executorName}, errUnsupportedExecutor
	}
}

func verifyTestIsSupported(atomicTest *art.Test) error {
	if atomicTest.Executor.Name == "" {
		return fmt.Errorf("invalid executor")
	}
	if atomicTest.Executor.Name == "manual" {
		return fmt.Errorf("manual tests cannot be run")
	}
	platform := getCurrentPlatform()
	for _, sp := range atomicTest.SupportedPlatforms {
		if platform == sp {
			return nil
		}
	}
	return fmt.Errorf("%q is not a valid test for %s", atomicTest.Name, getCurrentPlatform())
}

// Filter filters atomic techniques and tests based on a filter config and returns
// a new list of techniques.
func (ar *Runner) Filter(fc *FilterConfig) []*art.Technique {
	// atomic red team uses the platform name macos instead of darwin
	if fc.Platform == darwin {
		fc.Platform = macos
	}
	var filtered []*art.Technique
	var wantTechniques []string
	for _, tech := range fc.Techniques {
		if tech == "" {
			continue
		}
		// check if the techniqueID passed is valid
		if _, valid := ar.techniques[tech]; !valid {
			continue
		}
		wantTechniques = append(wantTechniques, tech)
	}
	// techniqueID's were passed but not valid
	if len(fc.Techniques) > 0 && len(wantTechniques) == 0 {
		return filtered
	}

	// no techniqueID's were passed, so
	if len(wantTechniques) == 0 {
		for _, technique := range ar.techniques {
			wantTechniques = append(wantTechniques, technique.ID)
		}
	}

	for _, wantTechnique := range wantTechniques {
		var atomicTests []*art.Test
		technique := ar.techniques[wantTechnique]
		// Apply the platform and manual test filters
		for _, test := range technique.AtomicTests {
			// skip manual tests if the filter does not ask to include it
			if !fc.IncludeManual && test.Executor.Name == "manual" {
				continue
			}
			// if no platform filters are set, add test
			if fc.Platform == "" {
				atomicTests = append(atomicTests, test)
				continue
			}
			// check if the atomic test is supported on the requested platform.
			for _, sp := range test.SupportedPlatforms {
				if sp == fc.Platform {
					atomicTests = append(atomicTests, test)
					break
				}
			}
		}
		if len(atomicTests) > 0 {
			filtered = append(filtered, &art.Technique{
				ID:          technique.ID,
				DisplayName: technique.DisplayName,
				Path:        technique.Path,
				AtomicTests: atomicTests,
			})
		}
	}
	return filtered
}

// processYAMLFolder recursively parses all yaml technique files inside the atomics folder
// and returns a list of techniques.
func (ar *Runner) processYAMLFolder() []art.Technique {
	location := ar.AtomicsFolder
	var files []string
	var techniques []art.Technique
	err := filepath.Walk(location, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if path != location && info.IsDir() && !strings.HasPrefix(info.Name(), "T") {
			ar.debugf("skipping subdirectory %s\n", path)
			return filepath.SkipDir
		}
		if filepath.Ext(path) == ".yaml" {
			files = append(files, path)
		}
		return nil
	})
	if err != nil {
		return techniques
	}

	for _, file := range files {
		tests, err := parseYAMLFile(file)
		if err != nil {
			ar.debugf("unable to parse file %s: %s\n", file, err)
		}

		ar.debugf("loading yaml file %s\n", file)
		// handle extra fields that are not part of the standard atomic yaml specification.
		// adding path and technique id to every test
		tests.Path = file
		for index := range tests.AtomicTests {
			tests.AtomicTests[index].TechniqueID = tests.ID
		}
		techniques = append(techniques, tests)
	}
	return techniques
}
